---
layout: post
title:  "Файловая система Linux"
crawlertitle: "Основы конфигурирования Linux"
summary: "Файловая система"
date:   2022-05-08 23:09:47 +0700
categories: posts
tags: ['Дата аналитика']
#author: Felipe
---

Linux поддер­живает множество систем, в том числе и используемые Windows файловые систе­мы FAT, FAT32 и NTFS, но при установке ОС Linux желательно выбрать родную ей систему: Ext2, Ext3, Ext4* или ReiserFS (это название часто сокращают до
Reiser). Система ReiserFS является диковиной, потому что используется нечасто, но она наиболее предпочтительна по сравнению с Ext2, поскольку включает жур­налирование, которое делает систему более устойчивой и позволяет быстро восста­навливать ее после сбоев.

Рассмотрим, как работают эти файловые системы, чтобы вы смогли выбрать опти­мальный вариант.

* В файловой системе Ext2 данные сначала кэшируются и только потом записы­ваются на диск, за счет чего достигается высокая производительность. Но если возникнут проблемы с питанием или произойдет аварийный выход из системы, то компьютер может не успеть сохранить данные. При следующей загрузке ОС обнаружит нарушение целостности жесткого диска, и запустится программа
сканирования диска fsck (аналог scandisk в Windows), которая восстановит его работоспособность. Однако воссоздать утерянные данные уже не удастся. Ска­нирование занимает много времени, и это может сказаться на скорости возоб­новления работы сервера. Будьте готовы к тому, что следующая загрузка будет происходить дольше обычного.

* В файловой системе ReiserFS также выполняется запись с предварительным кэшированием, после чего проверяется целостность данных и, если данные за­писаны верно, кэш очищается. В противном случае ОС при запуске с помощью созданного журнала быстро найдет проблемные места и с минимальными'поте-рями времени восстановит работоспособность диска.

* Файловая система Ext3 также принадлежит к новому поколению журналируе­мых систем и работает аналогично ReiserFS. До появления Ext4 она являлась системой по умолчанию в большинстве современных дистрибутивов Linux. Трудно сравнить по производительности ReiserFS и Ext3, но с точки зрения на­дежности советую использовать последнюю. Разные специалисты придержива­ются различных мнений, но я думаю, что стоит согласиться с мнением разработ­чиков и выбрать Ext3 или ее логическое продолжение Ext4.

* Четвертое пришествие Extended File System (Ext4) принесло возможность созда­вать диски размером в 1 эксбибайт (2 в 60-й степени) при размере блока в 4 ки­лобайта. Но более интересным, на мой взгляд, является механизм, который по­зволяет заранее выделить место под файл и дописывать новые данные в конецуже существующего. Таким образом уменьшается фрагментация данных и по­вышается производительность файловой системы.


Давай пос­мотрим на струк­туру катало­гов, которую ты уви­дишь поч­ти в любом Linux:

- `/` — кор­невая пап­ка, или, как ее еще называ­ют, root directory — пап­ка, в которой хра­нит­ся все осталь­ное содер­жимое фай­ловой сис­темы;
- `/bin` (от сло­ва binary) — здесь лежат дво­ичные исполня­емые фай­лы со все­ми основны­ми коман­дами;
- `/boot` — здесь рас­положен заг­рузчик и ядро ОС (фай­лы `vmlinuz` — это как раз оно и есть);
- `/dev` — фай­лы в этой пап­ке — это пор­ты и устрой­ства. Работая с эти­ми фай­лами, при­ложе­ния и драй­веры могут обме­нивать­ся информа­цией нап­рямую с обо­рудо­вани­ем. Впро­чем, некото­рые фай­лы — это не нас­тоящие устрой­ства, а вир­туаль­ные. Нап­ример, зна­мени­тый `/dev/null` при­нима­ет любую информа­цию и ничего с ней не дела­ет, а `/dev/random` генери­рует слу­чай­ные чис­ла;
- `/etc` — в этой пап­ке содер­жатся обще­сис­темные фай­лы кон­фигура­ции (тог­да как поль­зователь­ские фай­лы кон­фигура­ции находят­ся в домаш­нем катало­ге каж­дого поль­зовате­ля). Если ты адми­нис­тра­тор сис­темы, то сюда при­дет­ся час­то заг­лядывать при нас­трой­ке раз­ных прог­рамм;
- `/home` — в этой пап­ке содер­жатся домаш­ние катало­ги поль­зовате­лей Linux. Нап­ример, если твое имя поль­зовате­ля — `xakep`, твоя домаш­няя пап­ка будет называть­ся `/home/xakep/`;
- `/lib` — пап­ка для хра­нения биб­лиотек, необ­ходимых исполня­емым фай­лам в пап­ках `bin` и `sbin`;
- `/lost+found` — в эту пап­ку сох­раня­ются вос­ста­нов­ленные в слу­чае сис­темно­го сбоя фай­лы;
- `/media` — в некото­рых сис­темах допол­нитель­ный каталог, где отоб­ража­ются все смон­тирован­ные в сис­теме съем­ные носите­ли информа­ции. В ста­рых ОС может называть­ся `/cdrom`;
- `/mnt` — пап­ка, содер­жащая вре­мен­ные точ­ки мон­тирова­ния: сюда мон­тиру­ются фай­ловые сис­темы для вре­мен­ного исполь­зования;
- `/opt` — каталог содер­жит под­катало­ги для допол­нитель­ных пакетов прог­рам­мно­го обес­печения. Обыч­но исполь­зует­ся проп­риетар­ным ПО, которое не под­чиня­ется стан­дар­тной иерар­хии фай­ловой сис­темы Linux;
- `/proc` — каталог со спе­циаль­ными фай­лами, которые пре­дос­тавля­ют информа­цию о сис­теме и про­цес­сах;
- `/root` — домаш­ний каталог супер­поль­зовате­ля root;
- `/run` — этот каталог пре­дос­тавля­ет при­ложе­ниям стан­дар­тное мес­то для фай­лов, сущес­тву­ющих толь­ко во вре­мя работы сис­темы (отсю­да наз­вание), таких как сокеты и иден­тифика­торы про­цес­сов;
- `/sbin` — эта пап­ка по сво­ему наз­начению ана­логич­на пап­ке `bin`. Здесь лежат дво­ичные исполня­емые фай­лы, которые обыч­но пред­назна­чены для запус­ка поль­зовате­лем `root` в целях сис­темно­го адми­нис­три­рова­ния;
- `/tmp` — пап­ка для хра­нения вре­мен­ных фай­лов по умол­чанию;
- `/srv` — содер­жит дан­ные о сер­висах, пре­дос­тавля­емых сис­темой;
- `/usr` — в этой пап­ке содер­жатся при­ложе­ния и фай­лы поль­зовате­лей сис­темы. В ста­рых Unix это был ана­лог `/home`, но затем эти вещи раз­делили. Условно: в `/usr/` — прог­раммы, в `/home` — вся­кое барах­ло. Находя­щиеся здесь катало­ги `/usr/bin`, `/usr/sbin` и `/usr/lib` рань­ше име­ли то же наз­начение, что и ана­логи, лежащие в кор­не, но для фай­лов поль­зовате­лей (в то вре­мя как пап­ки в кор­не — для фай­лов, исполь­зуемых самой сис­темой). А еще есть каталог `/usr/local`, где есть свои `bin`, `sbin` и `lib`! Ког­да‑то под­разуме­валось, что здесь будут прог­раммы, спе­цифич­ные для кон­крет­ного компь­юте­ра, то есть в теории завися­щие от его железа. На прак­тике софт сюда попада­ет по самым раз­ным при­чинам;
- `/var` — от сло­ва variable, то есть что‑то, что может менять­ся. Здесь лежат бэкапы, кеши, биб­лиоте­ки, логи и тому подоб­ные вещи. Одна из важ­ных дирек­торий — это `/var/www`, где хра­нят­ся дан­ные веб‑сай­тов, если на машине уста­нов­лен веб‑сер­вер.

В сов­ремен­ной Ubuntu /bin, /sbin и /lib — это сим­воличес­кие ссыл­ки на соот­ветс­тву­ющие катало­ги в /usr

## Основные команды

Давайте рассмотрим основные команды файловой системы, которые мы будем ис­пользовать, и заодно подробнее познакомимся с файловой системой Linux. 

{% highlight r %}
pwd
{% endhighlight %}

Эта команда выводит на экран полный путь к текущему каталогу. С ее помощью выможете в любой момент узнать, где находитесь, если вдруг заблудитесь в этом пре­красном пингвиньем лесу.

{% highlight r %}
ls
{% endhighlight %}

Команда is выводит список файлов и подкаталогов указанного каталога. Если имя каталога (файла) отсутствует в параметрах команды, то отображается содержимое текущего каталога. По умолчанию все настроечные файлы (имена которых начи­наются с точки) являются скрытыми. Чтобы их вывести, нужно указать ключ -а:

{% highlight r %}
ls -а
{% endhighlight %}

Если мы, кроме этого, хотим увидеть не только имена (сжатый формат), но и пол­ную информацию о файлах в каталоге, нужно добавить ключ -1. То есть выполнить команду:

{% highlight r %}
ls -al
{% endhighlight %}

Однако такая команда отобразит файлы текущего каталога, и не факт, что мы сей­час находимся, например, в каталоге /etc, который хотим просмотреть. Чтобы уви­деть его содержимое, после ключей (а можно и до них) нужно указать требуемую папку:

{% highlight r %}
ls -al /etc
{% endhighlight %}

## **Дата и время изменения**

Самый простейший способ контроля — наблюдение за датой/временем редактиро­вания. Чтобы узнать, что было изменено, можно с помощью команды find запустить поиск всех файлов, у которых дата корректировки позже этого времени.

Cделать это легко, но не очень эффективно, потому что можно изме­нить дату/время редактирования файла с помощью команды touch, которая выгля­дит так:

{% highlight r %}
touch параметры ММДДччммГГ файл
{% endhighlight %}

Рассмотрим пример. Допустим, что вы хотите установить на файл /etc/passwd дату изменения 11:40 21 января. Для этого выполняем следующую команду:

{% highlight r %}
touch 01211140 /etc/passwd
{% endhighlight %}

Теперь воспользуйтесь командой is -1 /etc/passwd, чтобы убедиться, что дата ивремя изменения установлены верно.

С помощью команды touch можно и создавать файлы, сразу же указывая необхо­димую дату.

Как видите, даты создания и редактирования файлов легко меняются.

Итак, найти все файлы, дата изменения которых позже 11:40 21 января текущего года, можно следующим образом:

{% highlight r %}
touch 0121114010 /tmp/tempfile
find /etc \(-newer /tmp/tempfile \) -ls
find /etc \(-cnewer /tmp/tempfile \) -ls.
find /etc \(-anewer /tmp/tempfile \) —ls
{% endhighlight %}

В первой строке мы создаем во временном каталоге /tmp файл с необходимой датой изменения, по которой и будет происходить поиск.

Следующие три строки производят поиск файлов. Каждая из них имеет следующую структуру:

{% highlight r %}
find каталог \( -сравнение файл \) -ls
{% endhighlight %}

Рассмотрим по частям эту строку:

* find — программа поиска файлов;
* каталог — каталог, в котором нужно искать. В нашем случае указан системный каталог /etc, в котором хранятся все настроечные файлы;
* параметр \ ( -сравнение файл \) состоит из файла для сопоставления и критерия поиска файлов, который может принимать различные значения:
  * -newer — дата изменения позже, чем у заданного файла в параметре файл;
  * -cnewer — состояние изменено позже, чем у сопоставляемого файла в пара­метре файл;
  * -anewer— дата последнего доступа превосходит аналогичный параметр сравниваемого файла;
* параметр -ls — отображает на экране список файлов (как при выполнении команды ls).

## **Контрольные суммы**

На даты изменения можно надеяться, но необходимо иметь дополнительное средство проверки. Наилучшим методом является подсчет контрольной суммы. Допус­тим, что вы хотите отслеживать изменения в каталоге /etc. Для этого выполните следующую команду:

{% highlight r %}
find каталог \( -сравнение файл \) -ls
{% endhighlight %}

Утилита md5sum подсчитывает контрольную сумму указанных в качестве парамет­ра файлов. На экране вы получите результат выполнения команды примерно такого вида:
{% highlight r %}
783fd8fc5250c439914e88d490090ael /etc/DIR_COLORS
e2eb98e82a51806fe310bffdd23ca851 /etc/Muttrc
el043de2310c8dd266eb0ce007ac9088 /etc/a2ps-site.cfg
4543eebd0f473107e6e99ca3fc7b8d47 /etc/a2ps.cfg
cO 9badb7 774 9eecbeafd8 cb21c5 62bd6 /etc/adj time
70abal6e0d529c3db01a20207fd66blf /etc/aliases
c3e3a40097daed5c27144f53f37de38e /etc/aliases.db
3e5bb9f9e8616bd8a5a4d7247f4d858e /etc/anacrontab
fe4aad090adcd03bf686103687d69f64 /etc/aspldr.conf
{% endhighlight %}

Результат отображается в две колонки: первая содержит контрольную сумму, а вторая — имя файла. Контрольные суммы подсчитываются только для файлов. Для каталогов будет выведено сообщение об ошибке.

В нашем случае показаны все файлы каталога /etc/*. Результат расчета выведен на экран, но запомнить столько данных невозможно, поэтому логично будет запи­сать их в файл, чтобы потом использовать его содержимое для анализа изменений. Следующая команда выполняет расчет контрольных сумм и сохраняет ре­зультат расчета в файл /home/username/md:

{% highlight r %}
md5sum /etc/* >> /home/username/md
{% endhighlight %}

Чтобы сравнить текущее состояние файлов каталога /etc с содержимым файла /home/flenov/md, необходимо выполнить команду:

{% highlight r %}
md5sum -c /home/username/md
{% endhighlight %}

На экране появится список всех файлов, и напротив каждого должна стоять над­пись Success (Успех). Это означает, что изменений не было. Давайте модифициру­ем какой-нибудь файл, выполнив, например, следующую команду:

{% highlight r %}
groupadd test
{% endhighlight %}

Пока не будем вдаваться в подробности этой команды, сейчас достаточно знать, что она изменяет файл /etc/group. Снова выполняем команду проверки контрольных сумм файлов:

{% highlight r %}
md5sum -c /home/username/md
{% endhighlight %}

Теперь напротив файла /etc/group будет выведено сообщение об ошибке, поскольку его контрольная сумма изменилась. Таким образом, даже если дата корректировкифайла осталась прежней, по контрольной сумме легко определить наличие вмеша­тельства.

Программа md5sum входит в пакет ucommon-utils, который по умолчанию в Ubuntu-сервер не устанавливается. Если у вас этот пакет отсутствует, то для его установки следует выполнить команду:

{% highlight r %}
sudo apt-get install ucommon-utils
{% endhighlight %}

Можно контролировать изменения как конфигурационных файлов, так и всех сис­темных программ и библиотек. Я бы добавил мониторинг каталогов /etc и /bin.

Следить за пользовательскими файлами просто не имеет смысла, потому что эти файлы изменяются часто, и в тысячах изменений найти что-либо существенное будет проблематично. Системные библиотеки также изменяются с каждой установкой обновлений. А вот конфигурационные файлы и программы в настроенной системе не изменяются и не должны изменяться, поэтому любые их корректировки указы­вают на возможную проблему или вторжение.

* Разница между «>» и «>>» в Linux

Оба оператора являются операторами направления вывода. Основное отличие указано ниже:

    > : Перезаписывает существующий файл или создает файл, если файл с указанным именем отсутствует в каталоге.
    >> : добавляет существующий файл или создает файл, если файл с указанным именем отсутствует в каталоге.


## **ПОЛЬЗОВАТЕЛИ, ПРАВА НА ФАЙЛЫ**

Linux изна­чаль­но задумы­вал­ся как мно­гополь­зователь­ская сис­тема, а потому раз­деление фай­лов и про­филей поль­зовате­лей здесь орга­низо­вано на высочай­шем уров­не. Поль­зователь с огра­ничен­ными пра­вами в сис­теме может вза­имо­дей­ство­вать с теми или ины­ми фай­лами и катало­гами.

Важ­но пом­нить, что в Linux сущес­тву­ет супер­поль­зователь с име­нем `root`, обла­дающий пол­ными адми­нис­тра­тор­ски­ми при­виле­гиями в опе­раци­онной сис­теме, — так ска­зать, самый глав­ный босс всех бос­сов. Он может соз­давать и уда­лять учет­ки дру­гих юзе­ров и вооб­ще менять гло­баль­ные нас­трой­ки ОС. Любой юзер может вре­мен­но побывать в роли `root` с помощью коман­ды `sudo` (Substitute User and do, дос­ловно «под­менить поль­зовате­ля и выпол­нить»). Но сра­бота­ет этот sudo, толь­ко если ты зна­ешь пароль от учет­ной записи супер­поль­зовате­ля.

Каж­дому фай­лу в Linux наз­нача­ется набор раз­решений, опре­деля­ющих, кто и что может делать с этим фай­лом. Эти раз­решения обоз­нача­ются спе­циаль­ными бук­вами:

- `r` (read) — раз­решение на чте­ние фай­ла;
- `w` (write) — раз­решение на запись в файл;
- `x` (execute) — раз­решение на запуск фай­ла;
- `` (про­черк) — раз­решение не уста­нов­лено.

Важ­но пом­нить, что катало­ги Linux тоже счи­тает фай­лами, поэто­му для них дей­стви­тель­ны все те же раз­решения и огра­ниче­ния. Одна­ко ука­зан­ные раз­решения не име­ли бы боль­шого смыс­ла, если бы они рас­простра­нялись на всех поль­зовате­лей опе­раци­онной сис­темы. К счастью, это не так: в Linux име­ется три катего­рии поль­зовате­лей, для каж­дой из которых мож­но уста­нав­ливать свои собс­твен­ные раз­решения дос­тупа к фай­лам:

- **вла­делец** — поль­зователь, который соз­дал этот файл или наз­начен его вла­дель­цем. Вла­дель­цем фай­ла может быть не толь­ко учет­ная запись, но и сама опе­раци­онная сис­тема или при­ложе­ние, которое соз­дало файл;
- **груп­па** — груп­па поль­зовате­лей, «при­вязан­ная» к дан­ному фай­лу. Ты можешь узнать, к какой груп­пе поль­зовате­лей отно­сит­ся твоя учет­ная запись, с помощью кон­соль­ной коман­ды `groups <username>`. Спи­сок всех зарегис­три­рован­ных в сис­теме групп обыч­но хра­нит­ся в пап­ке `/etc/group`;
- **дру­гие** — все, кто не отно­сит­ся к вла­дель­цу фай­лового объ­екта или груп­пам поль­зовате­лей.

Та­ким обра­зом, раз­решения дос­тупа к любому фай­лу или пап­ке мож­но записать в виде стро­ки, сос­тоящей из девяти сим­волов и име­ющей сле­дующий вид:

{% highlight r %}
rwxrwxrwx
{% endhighlight %}

Пер­вые три сим­вола здесь опре­деля­ют раз­решения для вла­дель­ца фай­лового объ­екта, вто­рые — для груп­пы, к которой отно­сит­ся вла­делец фай­ла или пап­ки, пос­ледние три — для всех осталь­ных. Раз­решения всег­да сле­дуют имен­но в таком поряд­ке: «чте­ние, запись, запуск», то есть `rwx`. Нап­ример, обоз­начение вида `rwxrw-r--` озна­чает, что вла­делец это­го фай­ла может делать с ним что угод­но, чле­ны его груп­пы — толь­ко читать и писать в файл, но не запус­кать его (раз­решение `x` не уста­нов­лено), а всем осталь­ным поль­зовате­лям сис­темы файл дос­тупен толь­ко на чте­ние.

Ес­ли эти раз­решения уста­нов­лены для пап­ки, это озна­чает, что поль­зовате­ли груп­пы так­же не смо­гут запус­кать хра­нящи­еся в ней фай­лы, а про­чим поль­зовате­лям открыт дос­туп к содер­жимому пап­ки исклю­читель­но в режиме read only.

Прос­мотреть пра­ва и раз­решения фай­лов и папок мож­но с помощью кон­соль­ной коман­ды `ls`, снаб­женной клю­чом `-l`.

Что­бы изме­нить пра­ва дос­тупа, сущес­тву­ет коман­да `chmod` (Change Mode). При помощи этой коман­ды мож­но даже не про­писы­вать все тре­буемые раз­решения вруч­ную: для лен­тяев в Linux пре­дус­мотре­ны циф­ровые обоз­начения стан­дар­тных наборов раз­решений. Нап­ример, коман­да `chmod 755 filename` прис­воит фай­лу `filename` раз­решения `rwxr-xr-x` (каж­дый поль­зователь име­ет пра­во читать и запус­кать на выпол­нение; вла­делец может редак­тировать), `chmod 777 filename` даст на выходе `rwxrwxrwx` (все могут делать все, что захотят), а «дьяволь­ская» коман­да `chmod 666 filename` — вер­нет `rw-rw-rw-` (все поль­зовате­ли могут читать и редак­тировать файл).

В сов­ремен­ном Linux сущес­тву­ют еще так называ­емые спе­циаль­ные раз­решения, но их мы рас­смат­ривать не будем: для начала информа­ции впол­не дос­таточ­но, что­бы чувс­тво­вать себя в сис­теме более‑менее уве­рен­но.

## **ССЫЛКИ**

В Windows сущес­тву­ют ярлы­ки — что это такое, объ­яснять, дума­ем, никому не нуж­но. В Linux вмес­то них ссыл­ки, при­чем двух видов — жес­ткие и сим­воличес­кие.

Жес­ткая ссыл­ка — это, счи­тай, наз­вание фай­ла. Прос­то в Linux их у фай­ла может быть нес­коль­ко, при­чем находить­ся они могут в раз­ных катало­гах. Сле­дова­тель­но, если ты соз­дашь жес­ткую ссыл­ку, а потом уда­лишь исходный файл, то он по‑преж­нему будет дос­тупен по ссыл­ке — ведь она ничем не хуже исходно­го наз­вания, которое ты стер!

Ес­ли же ты уда­лишь пос­леднюю жес­ткую ссыл­ку, фай­ловая сис­тема боль­ше не будет счи­тать, что файл сущес­тву­ет, и приз­нает мес­то, где он рас­положен, при­год­ным для записи дру­гой информа­ции.

Сим­воличес­кие ссыл­ки боль­ше похожи на стан­дар­тные ярлы­ки Windows. Они содер­жат адрес целево­го фай­ла или катало­га (жес­тких ссы­лок на каталог не быва­ет), и если он исчезнет, то ссыл­ка будет вес­ти «в никуда».

Жес­ткие ссыл­ки соз­дают­ся коман­дой `ln файл ссылка`, а если нуж­но сде­лать сим­воличес­кую ссыл­ку, добавь ключ `-s`.

# **Полезные шпаргалки**

Вся мощь команд Linux — в допол­нитель­ных парамет­рах, которые ты можешь ука­зать. Что­бы узнать о них, нуж­но читать справ­ку (man), но есть спо­собы схит­рить и облегчить себе жизнь.

- **[tldr pages](https://tldr.sh/)** — сок­ращен­ная вер­сия man, в которой дотош­ные опи­сания пок­ромса­ли до абсо­лют­ного миниму­ма ([под­робнее](https://xakep.ru/2017/12/15/www-tldr-pages/));
- **[cheat.sh](https://github.com/chubin/cheat.sh)** — онлай­новая база дан­ных с при­мера­ми популяр­ных вари­антов команд ([под­робнее](https://xakep.ru/2018/07/13/www-cheatsh/));
- **[Marker](https://github.com/pindexis/marker)** — похожая шту­ка, но офлай­новая и с под­сказ­ками «на лету» ([под­робнее](https://xakep.ru/2019/03/06/www-marker/));
- **[explainshell.com](https://explainshell.com/)** — сер­вис, который авто­мати­чес­ки раз­бира­ет слож­ную коман­ду и объ­ясня­ет зна­чение ее сос­тавных час­тей.

За­пом­нить все парамет­ры всех команд невоз­можно, поэто­му даже заяд­лые линук­соиды при­бега­ют к таким хит­ростям (и неус­танно изоб­рета­ют всё новые)!